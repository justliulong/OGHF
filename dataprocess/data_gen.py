'''zh-cn
数据生成器，(支持根据labelme格式的数据生成各种形变的表格，结果依旧是labelme的格式)
原始数据目录:
root_dir
├──dataset
│   ├── image.png|jpg
│   ├── image.json
│   ├── *.png|jpg
│   └── *.json 
└──data_gen.py # 脚本文件

最后生成的目录结构：
root_dir
├──dataset
│   ├── image.png|jpg
│   ├── image.json
│   ├── *.png|jpg
│   └── *.json 
├──output_dir
│    ├── image_<factor>_<axis>_1.png|jpg            # 由柱面扭曲生成的数据，factor为扭曲因子，axis为扭曲轴
│    ├── image_<factor>_<axis>_1.json               # 由柱面扭曲生成的数据，factor为扭曲因子，axis为扭曲轴
│    ├── image_<amplitude>_<wavelength>_2.png|jpg   # 由三角扭曲生成的数据，amplitude为振幅，wavelength为波长
│    ├── image_<amplitude>_<wavelength>_2.json      # 由三角扭曲生成的数据，amplitude为振幅，wavelength为波长
│    ├── *.png|jpg
│    └── *.json
├──cache.json # 缓存文件，用于记录已经生成的数据，避免重复生成
└──data_gen.py # 脚本文件

#? 使用方法：
进入root_dir目录，执行命令
python data_gen.py --i <dataset> --o <output_dir> --e 1 --s {--st <210> --m <3>}
具体参数的意义参考本脚本的入口函数(if __name__ == '__main__')中parser.add_argument的help
'''
'''en
data generator, (support to generate various deformed tables according to labelme format data, the result is still in the labelme format)
original data directory:
root_dir
├──dataset
│   ├── image.png|jpg
│   ├── image.json
│   ├── *.png|jpg
│   └── *.json 
└──data_gen.py # script file

finally generated directory structure:
root_dir
├──dataset
│   ├── image.png|jpg
│   ├── image.json
│   ├── *.png|jpg
│   └── *.json 
├──output_dir
│    ├── image_<factor>_<axis>_1.png|jpg            # data generated by cylindrical distortion, factor is the distortion factor, axis is the distortion axis
│    ├── image_<factor>_<axis>_1.json               # data generated by cylindrical distortion, factor is the distortion factor, axis is the distortion axis
│    ├── image_<amplitude>_<wavelength>_2.png|jpg   # data generated by triangular distortion, amplitude is the amplitude, wavelength is the wavelength
│    ├── image_<amplitude>_<wavelength>_2.json      # data generated by triangular distortion, amplitude is the amplitude, wavelength is the wavelength
│    ├── *.png|jpg
│    └── *.json
├──cache.json # cache file, used to record the generated data to avoid repeated generation
└──data_gen.py # script file

#? Usage:
Enter the root_dir directory and execute the command
python data_gen.py --i <dataset> --o <output_dir> --e 1 --s {--st <210> --m <3>}
The meaning of specific parameters is referenced in the entry function (if __name__ == '__main__') of this script parser.add_argument help

'''

import os
import cv2
import json
import numpy as np
import random


class DataGenerator():
    '''
    :param input_path: input original image and json files path (cause using labelme to annotate, the image and json files are in the same folder)
    :param output_path: output image and json files path
    :param epochs: epochs of the generator
    :param shadow: whether add shadow to the image
    :param shadow_threshold: threshold of the shadow, when the pixel value of CIE stand light is less than the threshold, will not add shadow
    :param amplitude_range: amplitude range of the wave
    :param wavelength_range: wavelength range of the wave
    :param scale_range: scale range of the wavelength with the amplitude change
    '''

    def __init__(self,
                 input_path,
                 output_path,
                 epochs,
                 shadow,
                 mode=3,
                 shadow_threshold=210,
                 amplitude_range=[20, 40],
                 wavelength_range=[1000, 2000],
                 scale_range=[10, 20]):
        self.input_path = input_path
        self.output_path = output_path
        self.epochs = epochs
        self.shadow = shadow
        self.shadow_threshold = shadow_threshold
        self.mode = mode
        self.image_suffix = ['.jpg', '.jpeg', '.png', '.bmp', '.tif']
        self.cache_file = os.path.join(os.path.dirname(__file__), 'cache.json')
        self.cache_data = self._load_cache()
        if amplitude_range[1] < amplitude_range[0]:
            raise ValueError("amplitude_range[1] should be greater than amplitude_range[0]")
        if wavelength_range[1] < wavelength_range[0]:
            raise ValueError("wavelength_range[1] should be greater than wavelength_range[0]")
        if scale_range[1] < scale_range[0]:
            raise ValueError("scale_range[1] should be greater than scale_range[0]")
        self.amplitude_range = amplitude_range
        self.wavelength_range = wavelength_range
        self.scale_range = scale_range

    def _load_cache(self):
        if os.path.exists(self.cache_file):
            with open(self.cache_file, "r") as f:
                return json.load(f)
        return []  # 初始化为空列表

    def _save_cache(self):
        with open(self.cache_file, "w") as f:
            json.dump(self.cache_data, f, indent=4)

    def _convert_to_serializable(self, obj):
        """
        dict -> json
        """
        if isinstance(obj, list):
            return [self._convert_to_serializable(item) for item in obj]
        elif isinstance(obj, dict):
            return {key: self._convert_to_serializable(value) for key, value in obj.items()}
        elif isinstance(obj, np.float32) or isinstance(obj, np.float64):
            return float(obj)
        elif isinstance(obj, np.int32) or isinstance(obj, np.int64):
            return int(obj)
        else:
            return obj

    def _add_random_shadow(self, img, center_brightness=0.1, edge_brightness=0.8):
        """
        add random shadow to the image

        :param img: input image
        :param center_brightness: center shade brightness (range in 0.0~1.0)
        :param edge_brightness: edge shade brightness (range in 0.0~1.0)
        
        :return: image with shadow
        """
        h, w, _ = img.shape

        # randomly choose a corner as the shadow center
        corner_choice = np.random.choice(['top-left', 'top-right', 'bottom-left', 'bottom-right'])
        if corner_choice == 'top-left':
            shadow_center_x, shadow_center_y = np.random.randint(0, int(w * 0.1)), np.random.randint(0, int(h * 0.1))
        elif corner_choice == 'top-right':
            shadow_center_x, shadow_center_y = np.random.randint(int(w * 0.9), w), np.random.randint(0, int(h * 0.1))
        elif corner_choice == 'bottom-left':
            shadow_center_x, shadow_center_y = np.random.randint(0, int(w * 0.1)), np.random.randint(int(h * 0.9), h)
        else:  # 'bottom-right'
            shadow_center_x, shadow_center_y = np.random.randint(int(w * 0.9), w), np.random.randint(int(h * 0.9), h)

        # create a gradient image
        gradient = np.zeros((h, w), dtype=np.float32)

        # basic of the distance to the center of the shade to calculate the shadow intensity
        for y in range(h):
            for x in range(w):
                distance_to_center = np.sqrt((x - shadow_center_x)**2 + (y - shadow_center_y)**2)
                max_distance = np.sqrt(
                    (w / 2)**2 + (h / 2)**2)  # max distance to the center of the image (diagonal distance)

                # calculate the shadow intensity, which is a function of the distance to the center of the shade center
                shadow_intensity = (distance_to_center / max_distance)

                # limte the range to [edge_brightness, center_brightness]
                shadow_intensity = max(shadow_intensity, 0)  # avoid negative value
                shadow_intensity = min(shadow_intensity, 1)  # limite the max value to 1

                # interpolate the shadow intensity to the gradient image
                gradient[y, x] = edge_brightness + (center_brightness - edge_brightness) * shadow_intensity

        # expand the gradient image to the image 3 channels
        gradient = np.stack([gradient] * 3, axis=-1)

        img = img.astype(np.float32) / 255.0  # normalize the image to [0, 1]
        shaded_img = img * gradient  # multiply the image with the gradient
        shaded_img = (shaded_img * 255).astype(np.uint8)  # denormalize the image to [0, 255]

        return shaded_img

    def _cylindrical_warp_points(self, points, h, w, factor, axis):
        warped_points = []
        # h, w = map_x.shape

        for x, y in points:
            if 0 <= y < h and 0 <= x < w:
                # use cos formula directly
                new_x = float(x)
                # delte_y = y * np.cos(factor * (axis * x - w) / w) - y
                new_y = float(y * np.cos(factor * (axis * x - w) / w))

                if new_x < 0 or new_x >= w or new_y < 0 or new_y >= h:
                    return False
                warped_points.append([new_x, new_y])
            else:
                warped_points.append([x, y])
        return warped_points

    def _warp_points(self, points, map_x, amplitude, wavelength):
        """
        use sin wave formula to calculate the new points

        :param points: list of points
        :param map_x: x coordinate of the points
        :param amplitude: amplitude of the wave
        :param wavelength: wavelength of the wave
        """
        warped_points = []
        h, w = map_x.shape

        for x, y in points:
            if 0 <= y < h and 0 <= x < w:
                new_x = float(x - amplitude * np.sin(2 * np.pi * y / wavelength))
                new_y = float(y - amplitude * np.cos(2 * np.pi * x / wavelength))
                if new_x < 0 or new_x >= w or new_y < 0 or new_y >= h:
                    return False
                warped_points.append([new_x, new_y])
            else:
                warped_points.append([x, y])
        return warped_points

    def _get_background_color(self, image):
        """
        get the background color of the image
        
        :param  image: input image

        :return: background color (format of (R, G, B))
        """
        pixels = image.reshape(-1, 3)

        return np.mean(pixels, axis=0)

    def _apply_cylindrical_warp(self, image, shapes, factor=0.8, axis=1.7):
        """
        apply cylindrical warp to the image
        
        :param image: input image
        :param factor: control the degree of the warp, the bigger the factor, the more distorted the image will be
        :param axis: control the position of the axis, for example, axis=2 means the axis is at the middle of the image, the axis will not be distorted, axis's value should be no less than 1, don't set it bigger than 6, or the distortion will be too severe

        :return: warped image
        """
        h, w = image.shape[:2]

        # samples distortion
        transformed_shapes = []
        for shape in shapes:
            if self._cylindrical_warp_points(shape['points'], h, w, factor, axis) == False:
                return False
            warped_points = self._cylindrical_warp_points(shape['points'], h, w, factor, axis)
            transformed_shape = {
                "label": shape["label"],
                "points": warped_points,
                "group_id": shape["group_id"],
                "description": shape["description"],
                "shape_type": shape["shape_type"],
                "flags": shape["flags"],
                "mask": shape["mask"],
            }
            transformed_shapes.append(transformed_shape)

        # create a new image with the same size as the original image to store the warped image
        warped_image = np.full_like(image, self.background, dtype=np.uint8)

        for x_prime in range(w):
            for y_prime in range(h):
                y = y_prime / np.cos(factor * (axis * x_prime - w) / w)
                x = x_prime
                if 0 <= x < w and 0 <= y < h:
                    warped_image[y_prime, x_prime] = image[int(y), int(x)]

        return warped_image, transformed_shapes

    def _apply_wave_warp(self, image, shapes, amplitude=20, wavelength=720):
        """
        apply wave warp to the image
        
        :param image: input image
        :param shapes: outline point list
        :param amplitude: amplitude of the wave
        :param wavelength: wavelength of the wave, the bigger the wavelength, the more distorted the image will be

        :return: warped image
        """
        h, w = image.shape[:2]

        map_x, map_y = np.meshgrid(np.arange(w, dtype=np.float32), np.arange(h, dtype=np.float32))

        map_x += amplitude * np.sin(2 * np.pi * map_y / wavelength)
        map_y += amplitude * np.cos(2 * np.pi * map_x / wavelength)

        transformed_shapes = []
        for shape in shapes:
            if self._warp_points(shape['points'], map_x, amplitude, wavelength) == False:
                return False
            warped_points = self._warp_points(shape['points'], map_x, amplitude, wavelength)
            transformed_shape = {
                "label": shape["label"],
                "points": warped_points,
                "group_id": shape["group_id"],
                "description": shape["description"],
                "shape_type": shape["shape_type"],
                "flags": shape["flags"],
                "mask": shape["mask"],
            }
            transformed_shapes.append(transformed_shape)

        warped_image = cv2.remap(image, map_x, map_y, interpolation=cv2.INTER_NEAREST, borderMode=cv2.BORDER_REFLECT)

        return warped_image, transformed_shapes

    def distort(self):
        if self.mode == 1:
            choice = 1
        elif self.mode == 2:
            choice = 2
        elif self.mode == 3:
            print("randomly distort image")
        else:
            ValueError("mode should be 1, 2 or 3")
            return

        for i in range(self.epochs):
            print(f"Epoch {i + 1} / {self.epochs} ......")
            for json_file in [f for f in os.listdir(self.input_path) if f.endswith('.json')]:
                with open(os.path.join(self.input_path, json_file), 'r') as f:
                    data = json.load(f)
                    shapes = data['shapes']
                    # 读取图像
                    for suffix in self.image_suffix:
                        if os.path.exists(os.path.join(self.input_path, json_file.split('.')[0] + suffix)):
                            image = cv2.imread(os.path.join(self.input_path, json_file.split('.')[0] + suffix))
                            break
                        else:
                            print(f"Image not found for {json_file}")
                            continue

                    image_resized = cv2.resize(image, (100, 100))  # 缩小尺寸为 100x100，减少计算
                    self.background = self._get_background_color(image_resized)
                    B, G, R = self.background
                    print(f"Background color: B={B}, G={G}, R={R}")
                    # calculation of brightness
                    brightness = 0.2989 * R + 0.587 * G + 0.114 * B
                    file_name = json_file.split('.')[0]

                    if self.mode == 3:
                        # randomly choose a mode
                        choice = random.choice([1, 2])

                    if choice == 1:
                        # generate a number between 10 and 50 randomly as an amplitude, the wavelength is also a number between 180 and 800. However, affected by amplitude, the larger the amplitude, the larger the wavelength
                        amplitude = random.randint(self.amplitude_range[0], self.amplitude_range[1])

                        # according to amplitude, calculate min_wavelength
                        scale = random.randint(self.scale_range[0], self.scale_range[1])

                        # calculation of min_wavelength, it is directly proportional to amplitude
                        min_wavelength = min(self.wavelength_range[0] + scale * (amplitude - 10),
                                             self.wavelength_range[1])
                        wavelength = random.randint(int(min_wavelength), self.wavelength_range[1])

                        # design a cache file to record the processed file and its corresponding amplitude and wavelength to avoid the same deformation image
                        u_key = (file_name, amplitude, wavelength, 2)
                        if u_key in self.cache_data:
                            print(
                                f"Skipping {json_file} as it has already been distorted with amplitude {amplitude} and wavelength {wavelength}"
                            )
                            continue
                        else:
                            if self._apply_wave_warp(image, shapes, amplitude, wavelength) == False:
                                print(f"the sampling point is out of bounds, cancel the image generation...")
                                continue
                            warped_image, wave_shape = self._apply_wave_warp(image, shapes, amplitude, wavelength)
                            print(f"using y = {amplitude} * sin(2 * pi * x / {wavelength}) to distort {json_file}")

                            # add shadow
                            if self.shadow and brightness > self.shadow_threshold:
                                edge_brightness = random.uniform(0.1, 0.3)
                                center_brightness = random.uniform(0.6, 0.9)
                                print(f'center_brightness: {center_brightness}, edge_brightness: {edge_brightness}')
                                warped_image = self._add_random_shadow(warped_image, center_brightness, edge_brightness)

                            # save image and label
                            images_name = file_name + f'_{amplitude}_{wavelength}_2' + suffix
                            json_name = file_name + f'_{amplitude}_{wavelength}_2' + '.json'

                            cv2.imwrite(os.path.join(self.output_path, images_name), warped_image)
                            # wave_shape need to be converted to serializable
                            data['shapes'] = self._convert_to_serializable(wave_shape)
                            data['imagePath'] = images_name
                            with open(os.path.join(self.output_path, json_name), 'w') as f:
                                json.dump(data, f, ensure_ascii=False, indent=4)
                            self.cache_data.append(u_key)  # add to cache
                            self._save_cache()

                    elif choice == 2:
                        axis = np.random.normal(2, 0.7)  # generate a random number with mean 2 and std 0.7
                        # Ensure that a is within [1, 5] range, round to 3 decimal places
                        axis = round(max(1, min(5, axis)), 3)

                        # calculate factor range
                        if axis < 2.5:
                            f_min, f_max = 0.7, 0.85
                        else:
                            range_scale = (axis - 2) / 3
                            f_min = 0.3 * (1 - range_scale)
                            f_max = f_min + 0.05 * (1 - range_scale)
                        factor = round(random.uniform(f_min, f_max), 3)

                        u_key = (file_name, factor, axis, 1)
                        if u_key in self.cache_data:
                            print(
                                f"Skipping {json_file} as it has already been distorted with factor {factor} and axis {axis}"
                            )
                            continue
                        else:
                            if self._apply_cylindrical_warp(image, shapes, factor, axis) == False:
                                print(f"the sampling point is out of bounds, cancel the image generation...")
                                continue
                            warped_image, wave_shape = self._apply_cylindrical_warp(image, shapes, factor, axis)
                            print(f"using y = y * cos({factor} * ({axis} * x - w) / w) to distort {json_file}")

                            # add shadow
                            if self.shadow and brightness > self.shadow_threshold:
                                edge_brightness = random.uniform(0.1, 0.3)
                                center_brightness = random.uniform(0.6, 0.9)
                                print(f'center_brightness: {center_brightness}, edge_brightness: {edge_brightness}')
                                warped_image = self._add_random_shadow(warped_image, center_brightness, edge_brightness)

                            # save image and label
                            images_name = file_name + f"_{str(factor).replace('.', '-')}_{str(axis).replace('.', '-')}_1" + suffix
                            json_name = file_name + f"_{str(factor).replace('.', '-')}_{str(axis).replace('.', '-')}_1" + '.json'

                            cv2.imwrite(os.path.join(self.output_path, images_name), warped_image)
                            # wave_shape need to be converted to serializable
                            data['shapes'] = self._convert_to_serializable(wave_shape)
                            data['imagePath'] = images_name
                            with open(os.path.join(self.output_path, json_name), 'w') as f:
                                json.dump(data, f, ensure_ascii=False, indent=4)
                            self.cache_data.append(u_key)  # add to cache
                            self._save_cache()


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Distort images and annotations')
    parser.add_argument('--i', type=str, required=True, help='Path to input images and annotations')
    parser.add_argument('--o', type=str, required=True, help='Path to output distorted images and annotations')
    parser.add_argument('--e', type=int, default=2, help='epochs of distortion')
    parser.add_argument('--s', action='store_true', help='Whether to add shadow')
    parser.add_argument(
        '--st',
        type=int,
        default=210,
        help=
        'Threshold for adding shadow, when the pixel value of CIE stand light is less than the threshold, will not add shadow, max is 255'
    )
    parser.add_argument(
        '--m',
        type=int,
        default=3,
        help=
        'way of images to distort, 1: only add trigonometric functions distort; 2: only add cylindrical distort; 3: random to cylindrical distort and trigonometric functions distort'
    )
    args = parser.parse_args()

    datagen = DataGenerator(args.i, args.o, args.e, args.s, args.m, args.st)
    datagen.distort()
